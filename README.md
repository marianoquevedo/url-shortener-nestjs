# Overview

URL shortening service using Node.js and Nest.

- Endpoints:
  - /encode - Encodes a URL to a shortened URL
  - /decode - Decodes a shortened URL to its original URL.
  - Both endpoints should return JSON
- There is no restriction on how your encode/decode algorithm should work. You just need to make sure that a URL can be encoded to a short URL and the short URL can be decoded to the original URL. **You do not need to persist short URLs to a database. Keep them in memory.**
- Provide detailed instructions on how to run your assignment in a separate markdown file
- Provide API tests for both endpoints

## How to run the service

```sh
npm install
npm run start:dev
```

This will start a node server listening in port 3001 (the default configured in .env)

### Example requests

#### Encode URL

```shell
curl -X 'POST' \
  'http://localhost:3001/encode' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://hertz.auto"
}'
```

#### Decode URL

```shell
curl -X 'GET' \
  'http://localhost:3001/decode/64rg' \
  -H 'accept: application/json'
```

The API can also be tested from the [docs endpoint](http://localhost:3001/docs).

## Testing

### Run all tests with coverage collection

```shell
npm run test:all
```

### Run unit tests

```shell
npm run test
```

### E2E tests

```shell
npm run test:e2e
```

## API docs

The service has a [docs endpoint](http://localhost:3001/docs) that is auto-generated by NestJS from the code annotations.

## Implementation

### Design decisions

#### D1: Use NestJS

The API is implemented using [NestJS](https://docs.nestjs.com/). I decided to use it since it provides a quick way to bootstrap a Node service. It uses Typescript by default and provides a lot of functionality out of the box like: routing, validation, error handling, logging, testing helpers, etc.

#### D2: Use a naive implementation for the Unique Id Generator

In a real-life scenario, this implementation of the unique Id generator will not work at all. But due to the simplicity of this case, I decided to go with a simple incrementing sequence number. In a real-life distributed systems scenario, other techniques like [Snowflake Ids](https://en.wikipedia.org/wiki/Snowflake_ID) or [ticket-based systems](https://towardsdatascience.com/ace-the-system-design-interview-distributed-id-generator-c65c6b568027) are recommended.

#### D3: Use base32 encoding

To transform the Id into a string that's URL-safe and relatively short length compared to a big integer or a Snowflake ID, I choose to use [Base-32 encoding](https://github.com/agnoster/base32-js#warning-this-is-a-base-32-implementation-not-the-base-32-implementation). On my research of URL shortener services, this seems to be the most common encoding used by them.

#### D4: Use [Pino](https://github.com/pinojs/pino) as logger

Pino is a battle-tested, low-overhead, and high-performance logger. Logging can become a bottleneck in high-traffic Node.js applications.
